<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>闭包</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/hexo-blog/./css/style.css"><link rel="shortcut icon" href="/hexo-blog/./favicon.ico"><link rel="apple-touch-icon" href="/hexo-blog/./apple-touch-icon.png"><link rel="stylesheet" href="/hexo-blog/./css/atom-one-dark.css"><meta name="generator" content="Hexo 4.2.0"></head><body><header class="al_header al_pos_fixed"><div class="al_header_container dis_flex_jcenter"><div class="al_header_container_left"><div class="al_header_site_title"><a href="/">Blog</a></div></div><div class="dis_flex_jcenter"><div class="al_header_setting"><svg class="al_header_icon"><use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-menu"></use></svg></div></div></div></header><div class="al_sidebar"><div class="al_sidebar_overlay al_full_cover"></div><div class="al_pos_fixed al_sidebar_cnt"><div class="dis_flex_acenter al_sidebar_header"><h3>Blog</h3><div class="al_sidebar_close al_header_setting"><svg class="al_header_icon"><use xmlns="http://www.w3.org/2000/svg" xlink:href="/assets/svg_icons.svg#svg-close"></use></svg></div></div><div class="al_sidebar_author_cnt"><div class="al_sidebar_author_info"><h4>zhangjingjie</h4><img class="al_sidebar_avatar" src="https://yourAvatorURL"><p></p></div></div></div></div><div class="al_page_background dis_flex_center al_full_cover"></div><div class="al_page_container"><div class="al_pos_ab al_fake_background"></div><div class="al_main_container al_main_page_container"><article class="al_article"><header><h1 class="al_page_title">闭包</h1><div class="al_page_info dis_flex"><div class="al_page_content_info">Mar 21, 2020 11:33 AM</div><div class="al_page_content_info">546 words</div><div class="al_page_content_info">2 minutes read</div><span class="tags"></span></div></header><section id="post-body"><p><strong>闭包：</strong>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行的，这时就产生了闭包</p>
<ol>
<li>为创建内部作用域而调用一个包装函数 </li>
<li>包装函数的返回值必须至少包括一个内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">return</span> fucnction()&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = fn();</span><br><span class="line"><span class="keyword">var</span> num = foo()</span><br></pre></td></tr></table></figure>
<p>从上面的例子中我们可以看见如果哦我们直接返回访问 a会得到 ReferenceError 错误 在<strong>作用域</strong>中说过无法访问函数作用域的内容（准确说是词法作用域）然后通过闭包的方法我们可以访问函数内的值  </p>
<p>通过该方法我们可以得到一个防止污染全局总用域的自增函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">add() </span><br><span class="line">add()</span><br></pre></td></tr></table></figure>
<p>也许这只是闭包功能的冰山一角</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(num);</span><br><span class="line">		&#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>事件循环</strong> 中定义setTimeout是一个宏函数 即所有程序执行完毕后才会执行 所以如果当你不用闭包的时候你等到的结果将是老铁 666666的结果 然后通过闭包将i作为参数num在函数体内保存 等setTimeout执行的时候即可获得该指 当然解决该问题还有别的手段(非闭包)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;....&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(num)</span><br><span class="line">	&#125;,<span class="number">1000</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>闭包</strong> 的延展AMD模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> modules = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> modules = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name,deps,impl</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;deps.length;i++)&#123;</span><br><span class="line">			deps[i] = modules[deps[i]]; </span><br><span class="line">		&#125;</span><br><span class="line">        modules[name]=impl.apply(impl,deps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> modules[name];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; define, <span class="keyword">get</span> &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过这个方法可以将方法存储在函数体内modules中 然后当需要调用时通过传入deps数组去获取存储在modules中的方法，当今前端模块的开发及发展的那么迅速，离不开闭包</p>
</section></article><nav class="dis_flex post-nav"><span class="prev"><a href="/hexo-blog/2020/03/24/This/"><span class="arrow">←</span>Newer Posts</a></span><span class="next"><a href="/hexo-blog/2020/03/20/%E6%8F%90%E5%8D%87/">Older Posts<span class="arrow">→</span></a></span></nav></div></div><script type="text/javascript" src="/hexo-blog/javascripts/highlight.pack.js"></script><script>document.querySelectorAll('figure.highlight').forEach(function(b){hljs.highlightBlock(b);});</script><div class="al_index_footer dis_flex dis_flex_center"><div class="al_index_footer_item al_index_footer_title">zhangjingjie</div><div class="al_index_footer_item al_index_footer_extra">Create By <a href="https://github.com/iGuan7u/Acetolog" target="_blank" rel="noopener">AcetoLog </a>· Power By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></div><div class="al_index_footer_item al_index_footer_extra_right">All Right Reserved</div></div><script type="text/javascript" async="async" src="/hexo-blog/javascripts/acelog.js"></script><script src="/hexo-blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>